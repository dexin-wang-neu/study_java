## HashMap原理

1. hashmap的table散列表在**第一次**put操作的时候才初始化（延迟、懒初始化），因为如果创建出来不用就给他创建了内存，就浪费了

2. 路由寻址算法（找在散列表中的位置）：(tab.length - 1) & hash

3. jdk1.8 尾插法将元素追加到链表尾部

4. 为什么要扩容？

   1. 为了解决哈希冲突导致的链化影响查询效率的问题，扩容回缓解该问题。

   2. 第一次放数据put的时候会调用resize方法，此时oldCap == null;

   3. 扩容之前的table数组大小**已经达到最大阈值**，就不扩容了，且将扩容条件设置为int最大值

   4. 正常时扩容时，**newCap = oldCap << 1**；就是扩容一倍；此时还要求扩容之前的容量 >= 16;

   5. 第一次添加数据生成散列表时：

      1. new HashMap(initCap,loadFactor)；new HashMap(initCap)；new HashMap(map)且map有值时：这三种创建的方式都会给传一个oldThr,此时newCap = oldThr
      2. 通过new HashMap()创建时，什么都不给传，此时的数组大小则为默认16

   6. newThr（扩容之后，下次再次出发扩容的条件）为零时(创建的时候传进来就是0或者扩容前容量小于16)，通过newCap * loadFactor计算得到 newThr

   7. 扩容的过程：

      1. 根据计算处的newCap创建一个更大的数组

      2. 当扩容之前有数据时：

         1. 取出每个链表的头节点或红黑树的根节点

         2. 当前节点只有一个节点，在新数组的位置并放入索引（hash & (newCap - 1)）

         3. 当是**红黑树**的时候

         4. 当时链表的时候

            1. 例如索引**15**位置的链表数据，15 = hash & (16 - 1) 也就是说，所有在15位置上的元素的hash值的最后四位是**1111**，那么当扩容到32位之后，重新计算元素的索引时，他只有两个位置**15、31**，因为其后四位的hash值为1111，前一位的hash值为**0|1**，那么只能落在这两个位置上。

               > 扩容的时候一个链表拆成了两个链表：**高位链表和低位链表**
               >
               > 拆分的方式：**hash & oldCap == 0 **
               >
               > ​	如：**.... 1  1111	&    16(1 0000)    =    1**，则加到高位链表，否则加入地位
               >
               > 

            2. 







## 红黑树

> 红黑树的性质

1. 每个节点要么是黑色，要么是红色
2. 根节点是黑色
3. 每个叶子节点（NIL)是黑色（NIL就是其他树的null）
4. 每个红色节点的两个子节点一定是黑色，不能有两个红色节点相连
5. 任意一节点到每个叶子节点的路径都包含数量相同的黑节点。俗称黑高。
   1. 如果一个节点存在黑子节点，那么该节点肯定有两个子节点。

**红黑树并不是一个完美的平衡二叉查找树**，但左子树和右子树的黑节点的层数是相等的，也即任意一个节点到每个叶子节点的路径都包含相同数量的黑节点，所以叫红黑树这种平衡为**黑色完美平衡**



> 红黑树能自平衡：**左旋、右旋、变色**

1. **变色**：节点的颜色由红变黑或由黑变红
2. **左旋**：以某个节点作为支点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为选装节点的右子节点，左子节点保持不变。
3. **右旋**：以某个节点作为支点（旋转节点），其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。



## MySQL

> 磁盘预读：预读的长度一般为页（page）的整数倍

**页**是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4K），贮存和磁盘以页为单位交换数据。

### 1.索引是什么？

1. 索引是帮助MySQL高效获取数据的数据结构

2. 索引存储在文件系统中

3. 索引的文件存储形式与储存引擎有关

4. 索引文件的结构

   1. hash

      1. 缺点：
         1. 利用hash存储的画需要将所有的数据文件添加到内存，比较耗费内存空间
         2. 如果所有的查询都是等值查询，那么hash确实很快，但是在企业或者实际共工作环境中范围查找的数据更多，而不是等职查询，因此hash就不太适合

   2. 二叉树

      缺点：无论是二叉树还是红黑树，都会因为树的深度过深而造成io次数变多，影响数据读取的效率。

   3. B树

      1. B树特点：
         1. 所有键值分布在整棵树中
         2. 搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找
         3. 每个节点最多拥有m个子树
         4. 根节点至少有2个子树
         5. 分支节点至少拥有m/2棵子树（除根节点和叶子节点外都是分支节点）
         6. 搜索叶子节点都在同一层，每个节点最多可以有m-1个key，并且升序排列

   4. B+树

      B+树是在B树的基础上做的一种优化，变化如下：

      * B+树每个节点可以包含更多的节点，这么做的原因：为了降低树的高度；将数据范围变为多个区间，区间越多，数据检索越快
      * 非叶子节点存储key，叶子节点存储key和数据
      * 叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高。

### 2.索引分类

1. 主键索引：

   主键是一种唯一性索引，但他必须指定为PRIMARY KEY，每个表只能由一个主键

2. 唯一索引

   索引列的所有值都只能出现一次，即必须唯一，值可以为空

3. 普通索引

   基本的索引类型，值可以为空，没有唯一性的限制

4. 全文索引

   全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建。

5. 组合索引

   多列值组成一个索引，专门用于组合搜索

